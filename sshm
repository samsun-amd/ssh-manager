#!/bin/bash

# Configuration
JSON_FILE="./ssh_remote.json"

# Dependency Check
for cmd in jq sshpass fping; do
    if ! command -v $cmd &> /dev/null; then
        [[ "$cmd" == "fping" ]] && continue
        echo "Error: '$cmd' is not installed."
        exit 1
    fi
done

print_usage() {
    echo "SSH Manager - Remote Access Tool"
    echo "--------------------------------"
    echo "Usage:"
    echo "  $(basename "$0") [-p] [-c \"command\"] <IP>                 : SSH to IP"
    echo "  $(basename "$0") [-p] [-c \"command\"] <Name|Num>           : SSH to ServerBMC|Client"
    echo "  $(basename "$0") [-p] [-c \"command\"] <Name|Num> host<N>   : SSH to ServerHost (NIC)"
    echo "  $(basename "$0") [-p] [-c \"command\"] <Name|Num> smc       : SSH to SMC via BMC"
    echo "  $(basename "$0") -s <source> <dest> <Name|Num>              : SCP file transfer"
    echo "  $(basename "$0") -s <source> <dest> <Name|Num> host<N>      : SCP to ServerHost"
    echo ""
    echo "Options:"
    echo "  -p    Perform a ping check before connecting"
    echo "  -c    Execute a remote command instead of opening interactive shell"
    echo "  -s    SCP file transfer mode (requires source and destination)"
    echo "  -h    Print this help message"
    echo "  -l    List all nodes"
    echo ""
    echo "SCP Examples:"
    echo "  # Upload file to remote"
    echo "  $(basename "$0") -s local_file.txt remote:/path/to/dest/ target"
    echo ""
    echo "  # Download file from remote"
    echo "  $(basename "$0") -s remote:/path/to/file.txt local_dest/ target"
    echo ""
    echo "  # Upload directory (recursive)"
    echo "  $(basename "$0") -s local_dir/ remote:/path/to/dest/ target"
    echo ""
    echo "  # Download from server host"
    echo "  $(basename "$0") -s remote:/path/file.txt ./ server1 host1"
    echo ""
    echo "  # Upload to SMC (via BMC)"
    echo "  $(basename "$0") -s local_file.txt remote:/tmp/ server1 smc"
}

# Function to ping and then SSH
do_ssh() {
    local u=$1 p=$2 i=$3 ju=${4:-} jp=${5:-} ji=${6:-}
    
    if [[ "$PING_CHECK" == "true" ]]; then
        local ping_target="$i"
        [[ -n "$ji" ]] && ping_target="$ji"
        echo -n "Pinging $ping_target... "
        if command -v fping &> /dev/null; then
            fping -c 1 -t 500 "$ping_target" > /dev/null 2>&1
        else
            ping -c 1 -W 1 "$ping_target" > /dev/null 2>&1
        fi

        if [[ $? -ne 0 ]]; then
            echo -e "\033[1;31mOFFLINE\033[0m"
            echo "Error: Target is not reachable. Connection aborted."
            exit 1
        else
            echo -e "\033[1;32mONLINE\033[0m"
        fi
    fi

    if [[ -n "$REMOTE_COMMAND" ]]; then
        if [[ -n "$ji" ]]; then
            echo -e "\033[1;32mExecuting command on $i ($u) via jump host $ji ($ju): $REMOTE_COMMAND\033[0m"
            sshpass -p "$p" ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                -o ProxyCommand="sshpass -p '$jp' ssh -W %h:%p -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $ju@$ji" \
                "$u@$i" "$REMOTE_COMMAND"
        else
            echo -e "\033[1;32mExecuting command on $i ($u): $REMOTE_COMMAND\033[0m"
            sshpass -p "$p" ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$u@$i" "$REMOTE_COMMAND"
        fi
        exit $?
    else
        if [[ -n "$ji" ]]; then
            echo -e "\033[1;32mConnecting to $i ($u) via jump host $ji ($ju)...\033[0m"
            sshpass -p "$p" ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                -o ProxyCommand="sshpass -p '$jp' ssh -W %h:%p -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $ju@$ji" \
                "$u@$i"
        else
            echo -e "\033[1;32mConnecting to $i ($u)...\033[0m"
            sshpass -p "$p" ssh -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$u@$i"
        fi
    fi
}

# Function to perform SCP transfer
do_scp() {
    local u=$1 p=$2 i=$3 ju=${4:-} jp=${5:-} ji=${6:-} 
    local source="$SCP_SOURCE" dest="$SCP_DEST"
    
    # Parse remote: prefix
    local upload=true
    local remote_path=""
    local local_path=""
    
    if [[ "$source" == remote:* ]]; then
        # Download: remote -> local
        upload=false
        remote_path="${source#remote:}"
        local_path="$dest"
    elif [[ "$dest" == remote:* ]]; then
        # Upload: local -> remote
        upload=true
        remote_path="${dest#remote:}"
        local_path="$source"
    else
        echo "Error: Either source or dest must have 'remote:' prefix"
        echo "Usage: $(basename "$0") -s <source> <dest> <target>"
        echo "  Upload:   $(basename "$0") -s local_file remote:/path/ target"
        echo "  Download: $(basename "$0") -s remote:/path/file ./ target"
        exit 1
    fi
    
    # Determine if recursive transfer needed
    local recursive_flag=""
    if [[ "$upload" == true ]]; then
        if [[ -d "$local_path" ]]; then
            recursive_flag="-r"
        elif [[ ! -e "$local_path" ]]; then
            echo "Error: Source file/directory '$local_path' does not exist"
            exit 1
        fi
    fi
    
    # Prepare SCP options
    local scp_opts=(-q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null)
    if [[ -n "$ji" ]]; then
        # We can only use "scp -O" in the BMC to SMC
        scp_opts+=(-O)
        scp_opts+=(-o "ProxyCommand=sshpass -p '$jp' ssh -W %h:%p -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $ju@$ji")
    fi
    
    if [[ "$upload" == true ]]; then
        if [[ -n "$ji" ]]; then
             echo -e "\033[1;32mUploading $local_path -> $u@$i:$remote_path (via $ji)...\033[0m"
        else
             echo -e "\033[1;32mUploading $local_path -> $u@$i:$remote_path\033[0m"
        fi
        
        # Construct final command
        local cmd_flags=("${scp_opts[@]}")
        [[ -n "$recursive_flag" ]] && cmd_flags+=("$recursive_flag")
        
        sshpass -p "$p" scp "${cmd_flags[@]}" "$local_path" "$u@$i:$remote_path"

    else
        if [[ -n "$ji" ]]; then
             echo -e "\033[1;32mDownloading $u@$i:$remote_path -> $local_path (via $ji)...\033[0m"
        else
             echo -e "\033[1;32mDownloading $u@$i:$remote_path -> $local_path\033[0m"
        fi

        # Check if remote is directory for recursive download
        local ssh_opts=(-q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null)
        if [[ -n "$ji" ]]; then
             ssh_opts+=(-o "ProxyCommand=sshpass -p '$jp' ssh -W %h:%p -q -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null $ju@$ji")
        fi
        
        local is_dir=$(sshpass -p "$p" ssh "${ssh_opts[@]}" "$u@$i" "[ -d '$remote_path' ] && echo 'yes' || echo 'no'" 2>/dev/null)
        if [[ "$is_dir" == "yes" ]]; then
            recursive_flag="-r"
        fi
        
        local cmd_flags=("${scp_opts[@]}")
        [[ -n "$recursive_flag" ]] && cmd_flags+=("$recursive_flag")
        
        sshpass -p "$p" scp "${cmd_flags[@]}" "$u@$i:$remote_path" "$local_path"
    fi
    
    local exit_code=$?
    if [[ $exit_code -eq 0 ]]; then
        echo -e "\033[1;32m✓ Transfer completed successfully\033[0m"
    else
        echo -e "\033[1;31m✗ Transfer failed with exit code $exit_code\033[0m"
    fi
    return $exit_code
}

# --- Parse Arguments ---
PING_CHECK="false"
REMOTE_COMMAND=""
REMOTE_COMMAND_SET="false"
SCP_MODE="false"
SCP_SOURCE=""
SCP_DEST=""
ARGS=()

# Process flags first
while [[ $# -gt 0 ]]; do
    case "$1" in
        -p) PING_CHECK="true"; shift ;;
        -c) REMOTE_COMMAND="$2"; REMOTE_COMMAND_SET="true"; shift 2 ;;
        -s) SCP_MODE="true"; SCP_SOURCE="$2"; SCP_DEST="$3"; shift 3 ;;
        -h|help|--help) print_usage; exit 0 ;;
        *) ARGS+=("$1"); shift ;;
    esac
done

# Restore positional parameters (the server name, number, or list command)
set -- "${ARGS[@]}"

# --- Main Logic ---

# Check if -c flag was used with empty command
if [[ "$REMOTE_COMMAND_SET" == "true" && -z "$REMOTE_COMMAND" ]]; then
    echo "Error: -c flag requires a non-empty command."
    exit 1
fi

# Check if -s flag was used with proper arguments
if [[ "$SCP_MODE" == "true" ]]; then
    if [[ -z "$SCP_SOURCE" || -z "$SCP_DEST" ]]; then
        echo "Error: -s flag requires both source and destination arguments."
        echo "Usage: $(basename "$0") -s <source> <dest> <target>"
        exit 1
    fi
fi

# If no parameters left after parsing flags, show help
if [[ -z "$1" ]]; then
    print_usage
    exit 0
fi

# 1. LIST COMMAND
if [[ "$1" == "list" || "$1" == "-l" ]]; then
    # Combine Header and Data into a single stream for 'column'
    (
        echo "Num|Type|Name|IP(s)"
        echo "---|---|---|---"
        jq -r 'to_entries | .[] | 
            if .value.type == "client" then
                "\(.key + 1)|Client|\(.value.name)|\(.value.ip)"
            elif .value.type == "smc" then
                "\(.key + 1)|SMC|\(.value.name)|\(.value.ip) (via BMC)"
            else
                "\(.key + 1)|Server|\(.value.name)|BMC: \(.value.bmc.ip), Hosts: \(.value.hosts | map(.ip) | join(","))"
            end
        ' "$JSON_FILE"
    ) | column -t -s '|'
    exit 0
fi

# 2. SINGLE PARAMETER (Number, IP, or Name)
if [[ $# -eq 1 ]]; then
    input="$1"

    # A. Number
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        idx=$((input - 1))
        node=$(jq ".[$idx]" "$JSON_FILE")
        [[ "$node" == "null" ]] && { echo "Error: Node $input not found."; exit 1; }
        
        if [[ $(echo "$node" | jq -r '.type') == "client" ]]; then
            u=$(echo "$node" | jq -r '.user')
            p=$(echo "$node" | jq -r '.pass')
            i=$(echo "$node" | jq -r '.ip')
        else
            u=$(echo "$node" | jq -r '.bmc.user')
            p=$(echo "$node" | jq -r '.bmc.pass')
            i=$(echo "$node" | jq -r '.bmc.ip')
        fi
        
        if [[ "$SCP_MODE" == "true" ]]; then
            do_scp "$u" "$p" "$i"
        else
            do_ssh "$u" "$p" "$i"
        fi
        exit 0
    fi

    # B. IP Search
    found=$(jq -r --arg ip "$input" '
        (.[] | select(.type=="client" and .ip==$ip) | {u:.user, p:.pass, i:.ip}) //
        (.[] | select(.type=="server") | .bmc | select(.ip==$ip) | {u:.user, p:.pass, i:.ip}) //
        (.[] | select(.type=="server") | .hosts[] | select(.ip==$ip) | {u:.user, p:.pass, i:.ip})
    ' "$JSON_FILE")
    if [[ -n "$found" ]]; then
        u=$(echo "$found" | jq -r .u)
        p=$(echo "$found" | jq -r .p)
        i=$(echo "$found" | jq -r .i)
        if [[ "$SCP_MODE" == "true" ]]; then
            do_scp "$u" "$p" "$i"
        else
            do_ssh "$u" "$p" "$i"
        fi
        exit 0
    fi

    # C. Name
    node=$(jq -r --arg n "$input" '.[] | select(.name == $n)' "$JSON_FILE")
    if [[ -n "$node" ]]; then
        if [[ $(echo "$node" | jq -r '.type') == "client" ]]; then
            u=$(echo "$node" | jq -r '.user')
            p=$(echo "$node" | jq -r '.pass')
            i=$(echo "$node" | jq -r '.ip')
        else
            u=$(echo "$node" | jq -r '.bmc.user')
            p=$(echo "$node" | jq -r '.bmc.pass')
            i=$(echo "$node" | jq -r '.bmc.ip')
        fi
        
        if [[ "$SCP_MODE" == "true" ]]; then
            do_scp "$u" "$p" "$i"
        else
            do_ssh "$u" "$p" "$i"
        fi
        exit 0
    fi
    echo "Error: Target '$input' not found."
    exit 1
fi

# 3. TWO PARAMETERS (Identifier + Target)
if [[ $# -eq 2 ]]; then
    identifier="$1"
    target="$2"
    
    if [[ "$identifier" =~ ^[0-9]+$ ]]; then
        idx=$((identifier - 1))
        node=$(jq ".[$idx]" "$JSON_FILE")
    else
        node=$(jq -r --arg n "$identifier" '.[] | select(.name == $n)' "$JSON_FILE")
    fi

    [[ "$node" == "null" || -z "$node" ]] && { echo "Error: '$identifier' not found."; exit 1; }

    if [[ "$target" == "bmc" ]]; then
        u=$(echo "$node" | jq -r '.bmc.user')
        p=$(echo "$node" | jq -r '.bmc.pass')
        i=$(echo "$node" | jq -r '.bmc.ip')
        if [[ "$SCP_MODE" == "true" ]]; then
            do_scp "$u" "$p" "$i"
        else
            do_ssh "$u" "$p" "$i"
        fi
    elif [[ "$target" == "smc" ]]; then
        # Get BMC information as jump host
        bmc_user=$(echo "$node" | jq -r '.bmc.user')
        bmc_pass=$(echo "$node" | jq -r '.bmc.pass')
        bmc_ip=$(echo "$node" | jq -r '.bmc.ip')
        
        if [[ "$bmc_user" == "null" || "$bmc_pass" == "null" || "$bmc_ip" == "null" ]]; then
            echo "Error: '$identifier' is not a server with BMC. SMC requires BMC jump host."
            exit 1
        fi
        
        # Get SMC information from config
        smc_node=$(jq -r '.[] | select(.type == "smc")' "$JSON_FILE")
        if [[ -z "$smc_node" ]]; then
            echo "Error: No SMC node found in configuration."
            exit 1
        fi
        
        smc_user=$(echo "$smc_node" | jq -r '.user')
        smc_pass=$(echo "$smc_node" | jq -r '.pass')
        smc_ip=$(echo "$smc_node" | jq -r '.ip')
        
        if [[ "$SCP_MODE" == "true" ]]; then
            do_scp "$smc_user" "$smc_pass" "$smc_ip" "$bmc_user" "$bmc_pass" "$bmc_ip"
        else
            do_ssh "$smc_user" "$smc_pass" "$smc_ip" "$bmc_user" "$bmc_pass" "$bmc_ip"
        fi
    elif [[ "$target" =~ ^host([0-9]+)$ ]]; then
        idx=$((${BASH_REMATCH[1]} - 1))
        host_data=$(echo "$node" | jq ".hosts[$idx]")
        [[ "$host_data" == "null" ]] && { echo "Error: $target not defined."; exit 1; }
        u=$(echo "$host_data" | jq -r '.user')
        p=$(echo "$host_data" | jq -r '.pass')
        i=$(echo "$host_data" | jq -r '.ip')
        if [[ "$SCP_MODE" == "true" ]]; then
            do_scp "$u" "$p" "$i"
        else
            do_ssh "$u" "$p" "$i"
        fi
    else
        echo "Error: Unknown target '$target'."
    fi
    exit 0
fi
